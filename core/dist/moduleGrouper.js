"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupSymbolsToModulesWithLLM = void 0;
exports.inferPathModuleHint = inferPathModuleHint;
exports.groupSymbolsByTagsOrPath = groupSymbolsByTagsOrPath;
const path_1 = __importDefault(require("path"));
const DEFAULT_MAX_SYMBOLS = 300;
const MIN_CLUSTER_SIZE = 3;
function slugify(value) {
    return value
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "_")
        .replace(/^_+|_+$/g, "")
        .replace(/_+/g, "_");
}
function titleFromId(clusterId) {
    if (!clusterId) {
        return "Core";
    }
    return clusterId.charAt(0).toUpperCase() + clusterId.slice(1);
}
function inferPathModuleHint(filePath) {
    const normalized = filePath.split(path_1.default.sep);
    const srcIndex = normalized.indexOf("src");
    if (srcIndex !== -1 && normalized[srcIndex + 1]) {
        const segment = normalized[srcIndex + 1];
        const ext = path_1.default.extname(segment);
        return ext ? path_1.default.basename(segment, ext) : segment;
    }
    if (normalized.length > 0 && normalized[0]) {
        return normalized[0];
    }
    return "core";
}
function naiveGroupByPath(symbols) {
    const groups = new Map();
    for (const symbol of symbols) {
        const moduleId = slugify(symbol.pathModuleHint) || "core";
        if (!groups.has(moduleId)) {
            groups.set(moduleId, []);
        }
        groups.get(moduleId).push(symbol);
    }
    return Array.from(groups.entries()).map(([clusterId, groupSymbols]) => ({
        clusterId,
        title: titleFromId(clusterId),
        description: `Autogenerated module for path group ${clusterId}`,
        symbols: groupSymbols
    }));
}
function buildTagFrequency(symbols) {
    const counts = new Map();
    for (const symbol of symbols) {
        const tags = symbol.semanticTags && symbol.semanticTags.length > 0
            ? symbol.semanticTags
            : symbol.baseTags || [];
        for (const tag of tags) {
            const normalized = tag.trim().toLowerCase();
            if (!normalized) {
                continue;
            }
            counts.set(normalized, (counts.get(normalized) || 0) + 1);
        }
    }
    return counts;
}
function choosePrimaryTag(symbol, tagCounts) {
    const sourceTags = symbol.semanticTags && symbol.semanticTags.length > 0
        ? symbol.semanticTags
        : symbol.baseTags || [];
    const tags = sourceTags.map((tag) => tag.toLowerCase()).filter(Boolean);
    if (tags.length === 0) {
        return null;
    }
    let best = tags[0];
    let bestCount = tagCounts.get(best) || 0;
    for (const tag of tags) {
        const count = tagCounts.get(tag) || 0;
        if (count > bestCount) {
            best = tag;
            bestCount = count;
        }
    }
    return best;
}
function groupByTags(symbols) {
    const tagCounts = buildTagFrequency(symbols);
    const groups = new Map();
    const fallbackGroups = new Map();
    for (const symbol of symbols) {
        const primaryTag = choosePrimaryTag(symbol, tagCounts);
        const clusterId = primaryTag ? slugify(primaryTag) : "";
        if (clusterId) {
            if (!groups.has(clusterId)) {
                groups.set(clusterId, []);
            }
            groups.get(clusterId).push(symbol);
            continue;
        }
        const fallbackId = slugify(symbol.pathModuleHint) || "misc";
        if (!fallbackGroups.has(fallbackId)) {
            fallbackGroups.set(fallbackId, []);
        }
        fallbackGroups.get(fallbackId).push(symbol);
    }
    for (const [clusterId, groupSymbols] of groups.entries()) {
        if (groupSymbols.length >= MIN_CLUSTER_SIZE) {
            continue;
        }
        for (const symbol of groupSymbols) {
            const fallbackId = slugify(symbol.pathModuleHint) || "misc";
            if (!fallbackGroups.has(fallbackId)) {
                fallbackGroups.set(fallbackId, []);
            }
            fallbackGroups.get(fallbackId).push(symbol);
        }
        groups.delete(clusterId);
    }
    const clusters = [];
    for (const [clusterId, groupSymbols] of groups.entries()) {
        clusters.push({
            clusterId,
            title: titleFromId(clusterId),
            description: `Autogenerated module for tag ${clusterId}`,
            symbols: groupSymbols
        });
    }
    for (const [clusterId, groupSymbols] of fallbackGroups.entries()) {
        clusters.push({
            clusterId,
            title: titleFromId(clusterId),
            description: `Autogenerated module for path group ${clusterId}`,
            symbols: groupSymbols
        });
    }
    return clusters;
}
/**
 * Group symbols into clusters by tags or path.
 * Uses tag frequency to determine primary grouping, falls back to path-based grouping.
 */
async function groupSymbolsByTagsOrPath(symbols, opts) {
    const maxSymbols = opts?.maxSymbolsPerCluster ?? opts?.maxSymbolsForLLM ?? DEFAULT_MAX_SYMBOLS;
    if (symbols.length === 0) {
        return [];
    }
    if (symbols.length > maxSymbols) {
        return naiveGroupByPath(symbols);
    }
    return groupByTags(symbols);
}
/** @deprecated Use groupSymbolsByTagsOrPath instead */
exports.groupSymbolsToModulesWithLLM = groupSymbolsByTagsOrPath;
