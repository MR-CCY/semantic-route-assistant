import path from "path";
import { Cluster, SymbolRecord } from "./v3Types";

export type ClusterOptions = {
  /** @deprecated Use maxSymbolsPerCluster instead */
  maxSymbolsForLLM?: number;
  maxSymbolsPerCluster?: number;
};

const DEFAULT_MAX_SYMBOLS = 300;
const MIN_CLUSTER_SIZE = 3;

function slugify(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_");
}

function titleFromId(clusterId: string): string {
  if (!clusterId) {
    return "Core";
  }
  return clusterId.charAt(0).toUpperCase() + clusterId.slice(1);
}

export function inferPathModuleHint(filePath: string): string {
  const normalized = filePath.split(path.sep);
  const srcIndex = normalized.indexOf("src");
  if (srcIndex !== -1 && normalized[srcIndex + 1]) {
    const segment = normalized[srcIndex + 1];
    const ext = path.extname(segment);
    return ext ? path.basename(segment, ext) : segment;
  }
  if (normalized.length > 0 && normalized[0]) {
    return normalized[0];
  }
  return "core";
}

function naiveGroupByPath(symbols: SymbolRecord[]): Cluster[] {
  const groups = new Map<string, SymbolRecord[]>();
  for (const symbol of symbols) {
    const moduleId = slugify(symbol.pathModuleHint) || "core";
    if (!groups.has(moduleId)) {
      groups.set(moduleId, []);
    }
    groups.get(moduleId)!.push(symbol);
  }

  return Array.from(groups.entries()).map(([clusterId, groupSymbols]) => ({
    clusterId,
    title: titleFromId(clusterId),
    description: `Autogenerated module for path group ${clusterId}`,
    symbols: groupSymbols
  }));
}

function buildTagFrequency(symbols: SymbolRecord[]): Map<string, number> {
  const counts = new Map<string, number>();
  for (const symbol of symbols) {
    const tags =
      symbol.semanticTags && symbol.semanticTags.length > 0
        ? symbol.semanticTags
        : symbol.baseTags || [];
    for (const tag of tags) {
      const normalized = tag.trim().toLowerCase();
      if (!normalized) {
        continue;
      }
      counts.set(normalized, (counts.get(normalized) || 0) + 1);
    }
  }
  return counts;
}

function choosePrimaryTag(symbol: SymbolRecord, tagCounts: Map<string, number>): string | null {
  const sourceTags =
    symbol.semanticTags && symbol.semanticTags.length > 0
      ? symbol.semanticTags
      : symbol.baseTags || [];
  const tags = sourceTags.map((tag) => tag.toLowerCase()).filter(Boolean);
  if (tags.length === 0) {
    return null;
  }
  let best = tags[0];
  let bestCount = tagCounts.get(best) || 0;
  for (const tag of tags) {
    const count = tagCounts.get(tag) || 0;
    if (count > bestCount) {
      best = tag;
      bestCount = count;
    }
  }
  return best;
}

function groupByTags(symbols: SymbolRecord[]): Cluster[] {
  const tagCounts = buildTagFrequency(symbols);
  const groups = new Map<string, SymbolRecord[]>();
  const fallbackGroups = new Map<string, SymbolRecord[]>();

  for (const symbol of symbols) {
    const primaryTag = choosePrimaryTag(symbol, tagCounts);
    const clusterId = primaryTag ? slugify(primaryTag) : "";
    if (clusterId) {
      if (!groups.has(clusterId)) {
        groups.set(clusterId, []);
      }
      groups.get(clusterId)!.push(symbol);
      continue;
    }

    const fallbackId = slugify(symbol.pathModuleHint) || "misc";
    if (!fallbackGroups.has(fallbackId)) {
      fallbackGroups.set(fallbackId, []);
    }
    fallbackGroups.get(fallbackId)!.push(symbol);
  }

  for (const [clusterId, groupSymbols] of groups.entries()) {
    if (groupSymbols.length >= MIN_CLUSTER_SIZE) {
      continue;
    }
    for (const symbol of groupSymbols) {
      const fallbackId = slugify(symbol.pathModuleHint) || "misc";
      if (!fallbackGroups.has(fallbackId)) {
        fallbackGroups.set(fallbackId, []);
      }
      fallbackGroups.get(fallbackId)!.push(symbol);
    }
    groups.delete(clusterId);
  }

  const clusters: Cluster[] = [];
  for (const [clusterId, groupSymbols] of groups.entries()) {
    clusters.push({
      clusterId,
      title: titleFromId(clusterId),
      description: `Autogenerated module for tag ${clusterId}`,
      symbols: groupSymbols
    });
  }

  for (const [clusterId, groupSymbols] of fallbackGroups.entries()) {
    clusters.push({
      clusterId,
      title: titleFromId(clusterId),
      description: `Autogenerated module for path group ${clusterId}`,
      symbols: groupSymbols
    });
  }

  return clusters;
}

/**
 * Group symbols into clusters by tags or path.
 * Uses tag frequency to determine primary grouping, falls back to path-based grouping.
 */
export async function groupSymbolsByTagsOrPath(
  symbols: SymbolRecord[],
  opts?: ClusterOptions
): Promise<Cluster[]> {
  const maxSymbols = opts?.maxSymbolsPerCluster ?? opts?.maxSymbolsForLLM ?? DEFAULT_MAX_SYMBOLS;

  if (symbols.length === 0) {
    return [];
  }

  if (symbols.length > maxSymbols) {
    return naiveGroupByPath(symbols);
  }

  return groupByTags(symbols);
}

/** @deprecated Use groupSymbolsByTagsOrPath instead */
export const groupSymbolsToModulesWithLLM = groupSymbolsByTagsOrPath;
